---
title: "Script_stage"
author: "Rémi Legrand"
date: "03/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Package à nécessaires
```{r message=FALSE}
library(reshape)
library(ROBITools2) #analyse des données métabarcoding
library(ggplot2) #affichage graphique avancé
library(dplyr) #pour manipuler les données
library(tidyr) #idem
library(stringr) #pour manipuler les chaînes de caractères
library(openxlsx) #pour manipuler les fichiers .xlsx
```

## Imporation des données
```{r}
motus <- read.table("motus_afrique_sud_remi.txt")
data <- read.table("data_afrique_sud_remi.txt")
samples <- read.table("samples_afrique_sud_remi.txt")
reference <- read.xlsx("Plant reference collection sequence information.xlsx",
                       sheet = 2)
```


# Prise en main et visualisation des données

head donne les 6 premières lignes
dim donne les dimensions
memo: peuplier[c(3,7,9),c('Annee','Hauteur')]
peuplier[peuplier$Age == x, ]
peuplier[peuplier$Hauteur > 10,c('Diametre','Age','Hauteur')]

```{r}
# View(motus)
# View(data)
# View(samples)
# View(reference)
# pour avoir nombre colonne et de lignes de motus:
```

ce que contiennent les jeux de données:
  - motus: contient l'id, le nombre de lecture et la séquence
  - data: contient le motu(=id), le numéro d'échantillon (plusieurs échantillons différents     pour un même motu) et son nombre de lecture
  - samples: contient chacune des séquences, l'espèce attendue, 
  - reference: nom de l'espèce et la séquence de référence associée


## Nombre de lecture par échantillon

C'est une donnée que l'on a déjà dans le fichier data, si nous voulons par motu, on l'a déjà dans le fichier motus.


Il suffirait de le faire en boucle for allant de 1 à length(motu) (ce n'est pas length mais plutôt width mais cette commande n'existe pas) et pour chaque itération remplacer le motu recherché et ainsi faire le somme et ensuite ajouter le résultat dans une liste contenant en première colonne le nom de l'échantillon et en deuxième le nombre de lecture de cet échantilon.

```{r}

length(motus)
nrow(motus)
```


## Nombre de variants par échantillons

```{r}
# nrow(samples)
compt=0
for (i in c(1:nrow(samples))) {
  if (!is.na(samples$observed_scientific_name[i])) {
    if (samples$observed_scientific_name[i] == "Loxodonta africana") {
    compt=compt+1
    }
  }
}
print(compt)
```

Permet de compter le nombre de fois qu'apparaît Loxodonta africana. mais cette méthode est beaucoup trop lente pour pouvoir être appliquée à la base de donnée en entier.
```{r}
table(samples$observed_scientific_name)# permet le nombre d’occurrence de chacun des noms scientifiques dans la base de donnée sous forme de table

samples%>%group_by(samples$observed_scientific_name)%>%summarise(echantillon = n()) # n() est une fonction de décompte
# permet aussi de compter le nombre d’occurrences mais donne le résultat sous la forme d'un data frame.
```

## Aprentissage de Robitools

```{r}

lcs_score("AAAA","AAATAA", similarity_mode = "distance")$score # permet de compter le nombre de différences entre deux séquences données.
lcs_score(motus[1,]$sequence, motus$sequence, similarity_mode = "distance")$score # permet de comparer une séquence à toutes les autre du fichier.

is_dist_1_or_0("AACAAGCC", c("AACAAGCC", "AAAAGCC", "ATCAAGCC", "AACATGCG"))
```

## Représentation des distances génétiques entre les variants à l'aide d'une Heatmap

Les 1 011 variants variants de la base de données ont été retenus sur un critère de similarité génétique. Étudie la distance entre chacun des variants. Représentation avec une heatmap. Comment interpréter ces proximités (ou non) entre les variants ?

```{r}
matrice <- matrix(data = 0, nrow = nrow(motus), ncol = nrow(motus))
# permet de créer une matrice aux dimension de motus

for (a in 1:nrow(motus)) {
  matrice[a,] <-lcs_score(motus[a,]$sequence, motus$sequence, similarity_mode = "distance")$score
}
# rentre les scores des distance entre les séquences dans matrice

lineaire <- melt(matrice)# permet de transformer la matrice en une matrice plus longue avec sa localisation en x et y ainsi que sa valeur, ce qui va permettre de faire une heatmap avec ggplot

colnames(lineaire) <- c("x", "y", "value")

ggplot(lineaire, aes(x = x, y = y, fill = value))+
  geom_tile() +
  coord_fixed() +
  ggtitle("Heatmap des distances entres les séquence de Motus")

# trace une heatmap
```

Cette heatmap contenant trop de valeurs pour être lisible, nous l'avons réduite en ne gardant que les  premières séquences.
De plus nous avons appliqué un log afin de mettre en valeur que un écart de 0 à 1 base est très important alors qu'un écart de 5 à 6 ne change pas grand chose.

```{r}
matrice50 <- matrice[1:50,1:50]

lineaire <- melt(matrice50)
colnames(lineaire) <- c("x", "y", "value")

ggplot(lineaire, aes(x = x, y = y, fill = log(value)))+
  geom_tile() +
  coord_fixed() + 
  ggtitle("Heatmap des 50 premières séquences")

```

## Déterminer les espèces de motus appartenant à base de donnée de réference et annotation de Motus

Une première difficulté est que certaines espèces (réelles) ont des séquences très proches les unes des autres. A partir de la base de référence fournie (Plant référence collection séquence information.xlsx ), peut-on distinguer des espèces réelles de probables erreurs PCR ? Annote la base de données "motus" avec l’espèce correspondante, quand elle est identifiée.

```{r}
# motus
# motus[ , "plant"] <- 0
# View(motus)

# for (c in 1:nrow(motus)) {
#   motus$plant[c] <-lcs_score(motus[c,]$sequence, reference$Taxonomic.rank, similarity_mode = "distance")$score
# }
## problème car ce que j'essaie d'implanter dans dans la colonne plant de motus n'a pas la même dimension que plant
```

Essai de faire fonctionner avec deux boucles for imbriquées l'une dans l'autre, ce qui a fonctionné mais est trop lent.
Il faut donc utiliser une seule boucle for comme écrit ci dessous.
```{r}
motus[ , "dans_ref"] <- F # créer une nouvelle colonne dans motus et l'initialiser avec des FALSE
for (c in 1:nrow(motus)) {
  if (motus$sequence[c] %in% reference$Sequence.ID) {
    motus$dans_ref[c] <- T
  }
} 
# chercher dans la base de données de référence et annoter TRUE quand cette séquence se trouve dans la base de référence. 

motus[ , "espece"] <- NA

for (c in 1:nrow(motus)) {
  if (motus$dans_ref[c]) {
    motus$espece[c] <- reference$Scientific.name[reference$Sequence.ID == motus$sequence[c]]
  }
}
# si il y a marqué TRUE dans la colonne "dans_ref", alors, il copie le nom de l'espèce qui a la même séquence.
```


# Indicateur de biodiversité

## Deffinition du nombre de HILL (diversité)

point 1.1.3 du Rapport de Sylvain Moinard

L’entropie est la surprise moyenne apportée par l’observation des individus d’une communauté, d’autant plus grande qu’un individu appartient à une espèce plus rare. 
L’entropie HCDT permet d’unifier les indices classiques de diversité : son paramètre, appelé ordre, fixe l’importance donnée aux espèces rares. L’entropie d’ordre 0 est la richesse ; celle d’ordre 1,l’indice de Shannon ; celle d’ordre 2, celui de Simpson.
L’entropie va de pair avec la diversité au sens strict (Nombres de Hill) : le nombre d’espèces équiprobables dont l’entropie est la même que celle de la communauté réelle. 
Les profils de diversité représentent la diversité en fonction de son ordre et permettent la comparaison de communautés.

L’estimation de la diversité est difficile pour des ordres inférieurs à 0, 5 dans des taxocènes très divers comme les arbres des forêts tropicales.
( page 54 du lire de Eric Marcon 2015)

On décide d’analyser une famille d’indices : les nombres de Hill, qui correspondent à un nombre équivalent d’espèces présentes dans l’écosystème étudié.

```{r}
# q=1
# sum(motus$count)
# sum(motus$count[motus$dans_ref==T])

# motus$count[e][motus$dans_ref == T]
## j'aimerais bien écrire cela mais je n'arrive pas à extraire ce que je veux, il faut donc que je passe par un if


# somme <- 0
# for (e in 1:nrow(motus)) {
#   if (motus$dans_ref[e] == TRUE){
#     somme <- somme + (motus$count[e]/sum(motus$count[motus$dans_ref==T]))^q
#   }
# }
# Hill <- somme^(1/(1-q))
# print(Hill)
# dans le cas où on ne veut étudier la diversité seulement sur les espèces répertoriées.




q=0
somme <- 0
if (q==1) {
  for (e in 1:nrow(motus)) {
    somme <- somme + (motus$count[e]/sum(motus$count))*log(motus$count[e]/sum(motus$count))
  }
  Hill <- exp(-somme)
  print("a")
}else{
  for (e in 1:nrow(motus)) {
    somme <- somme + (motus$count[e]/sum(motus$count))^q
  }
  Hill <- somme^(1/(1-q))
  print("b")
}
print(Hill)
# dans le cas où on veut étudier la diversité sur toutes les séquences
```
quand on exécute pour q=0, on obtient bien 18, ce qui correspond au nombre d'espèces étudiées
il reste le problème pour Q=0, il calcule -inf. il faut donc utiliser un dvp limité


plotter la biodiversité en fonction de q
```{r}
# réalisation d'une fonction que l'on pourra utiliser pour notre graphique
Biodiv <- function(q) {
  somme <- 0
  if (q==1) {
    for (e in 1:nrow(motus)) {
      somme <- somme + (motus$count[e]/sum(motus$count))*log(motus$count[e]/sum(motus$count))
    }
    Hill <- log(exp(-somme))
    # print("a")
  }else{
    for (e in 1:nrow(motus)) {
      somme <- somme + (motus$count[e]/sum(motus$count))^q
    }
    Hill <- log(somme^(1/(1-q)))
    # print("b")
  }
}
x <- seq(0,3,0.1)
plot(x,sapply(x, Biodiv, simplify = TRUE, USE.NAMES = TRUE),main = "Évolution de l'indice de biodiversité en fonction de q", type = "l",xlab = "valeur de q", ylab = "log (indice de biodiversité)")
# utilisation de sapply, nous permettant d'exécuter plusieurs fois la fonction avec des valeurs différentes 
#passer echelle log
# entre 0-3

# Apprendre à faire le graphique sous GGplot pour qu'il soit plus propre
```
que se passe il quand q tend vers infini

```{r}

```

## Étude des Ps, de leurs répartition et de leurs répartition selon leurs présence ou non dans la base de données.

tracer l'histogramme des log(ps) ainsi que ceux des log(ps) présents dans la référence et un autre avec ceux qui n'y sont pas

```{r}
ps <- c()

for (f in 1:nrow(motus)) {
  ps <- c(ps,motus$count[f]/sum(motus$count))
  
}
qplot(ps, main = "Histogramme de répartition ps ADN séquencé")+scale_y_log10()+scale_x_log10()
# dans le cas où on observe tout les ps
```
On peut  observer que très peu d'espèces ont un ps supérieur à 10^-2, et sont donc extremement représenté dans le nombre de lectures alors que la plus part des espèces ontmoins de 10^-2.

```{r}
ps <- c()
for (g in 1:nrow(motus)) {
  if (motus$dans_ref[g] == TRUE){
    ps <- c(ps,motus$count[g]/sum(motus$count[motus$dans_ref==T]))
  }
}
qplot(ps, main = "Histogramme de répartition ps espèces présentes dans fichier réference")
# dans le cas où on observe juste ceux présents dans la base de données de référence
```
Ici, on peut voir que la quasi totalité  des 

```{r}
ps <- c()
for (h in 1:nrow(motus)) {
  if (motus$dans_ref[h] == F){
    ps <- c(ps,motus$count[h]/sum(motus$count[motus$dans_ref==F]))
  }
}
qplot(ps, main = "Histogramme de répartition ps séquences absentes fichier réference")+scale_y_log10()+scale_x_log10()
# dans le cas où on observe juste ceux non présents dans la base de données de référence
```
*je pense qu'il sera dur de tirer des conclusions en comparant les différents graph étant donné que pour obtenir ps, on divise pas la somme des counts, qui n'est pas la même, ce sont donc deux infos mais difficilement comparables*



### re-agréger les données de data_count  afin de vérifier si on obtient bien motus_count

```{r}
data_count <- data%>%group_by(motu)%>%summarise(count = sum(count)) # n() est une fonction de décompte
# donc il y a un problème car j'obtient le nombre de fois que le motu apparais dans data


nrow(data_count)
data_count

nombre_f <- 0
data_count$count == motus$count
motus[ , "identique_data"] <- F
for (c in 1:nrow(motus)) {
  if (data_count$count[c] == motus$count[c]) {
    motus$identique_data[c] <- T
    
  }else{
    nombre_f <- nombre_f+1
  }
}
print(f)
```

**motus agrégé (ça je ne me souviens plus de ce que je devais faire).**



tracer l'évolution l'indicateur de biodiv en fonction de q échantillon par échantillon à partir du data


```{r}
# unique(data$sample)
nombre_q <- seq(1,10,0.5)
length(nombre_q)

longueur <- rep(0,10)
longueur
# (length(nombre_q)*(data%>%group_by(sample)%>%summarise(sample= n())))
```

```{r}
data%>%group_by(sample)%>%summarise(sample= n())


vecteur1 <- c(1:10) ; vecteur2 <- c(2:11)

tableau <- data.frame(x = vecteur1, y = vecteur2, z=vecteur2) 
tableau
matrice <- matrix(data = 0, nrow = nrow(motus), ncol = nrow(motus))
nom_sample <- unique(data$sample)
length(nom_sample)
matrice
```
```{r}
nombre_q <- seq(1,1,1)
nom_sample <- unique(data$sample)
length(nom_sample) # nombre d'échantillons différents
vecteur <- c(rep(NA,length(nom_sample)*length(nombre_q))) #création d'un vecteur de taille nombre d'échantillons * nombre de valeurs de q
# vecteur
tableau <- data.frame(sample = vecteur, q = vecteur, Dq= vecteur) 
tableau[1:5,"sample"] = rep(3,5)
# tableau

# for (a in 0:(length(nom_sample)-1)) {
#   tableau[(a*length(nombre_q)+1):((a+1)*length(nombre_q)),"sample"] <-rep(nom_sample[a+1],length(nombre_q))
# }
# tableau
# est une idée pas trop mauvaise en théorie mais beaucoup trop lent


# une autre solution proposée par sylvain, qui consiste à rajouter les lignes les unes après les autres

nombre_q <- seq(1,2,1)
df <- NULL
for (ech in unique(data$sample) ) {
  df <- rbind(df, data.frame(sample=ech,
              q=nombre_q,
              Qd=ifelse(nombre_q == 1,"oui","non")))
}
df

# sum(data$count == )
```
essai de faire fonctionner direct
```{r}
nombre_q <- seq(1,2,1)
df <- NULL
for (ech in unique(data$sample) ) {
  somme=0
  df <- rbind(df, data.frame(sample=ech,
              q=nombre_q,
              Qd=ifelse(nombre_q == 1,
              for (g in data[data$sample == "~04A_1",]$count) {
                ps=(g/(sum(data[data$sample == "~04A_1",]$count)))
                somme = somme + ps*log(ps)
                Hill <- exp(-somme)
                print("a")
              },
              for (g in data[data$sample == "~04A_1",]$count) {
                ps=(g/(sum(data[data$sample == "~04A_1",]$count)))
                somme = somme + ps^q
                Hill <- somme^(1/(1-nombre_q))
                print("b")
              })))
}
df
```

```{r}
# somme <- 0
# if (q==1) {
#   for (e in 1:nrow(motus)) {
#     somme <- somme + (motus$count[e]/sum(motus$count))*log(motus$count[e]/sum(motus$count))
#   }
#   Hill <- exp(-somme)
#   print("a")
# }else{
#   for (e in 1:nrow(motus)) {
#     somme <- somme + (motus$count[e]/sum(motus$count))^q
#   }
#   Hill <- somme^(1/(1-q))
#   print("b")
# }
# print(Hill)
```

version que j'ai faite mais moins propre
```{r}
# sum(data[data$sample == "~04A_1",]$count) # correspond au nombre de lectures totales pour l'échantillon Z24W_3
# nrow(data[data$sample == "~04A_1",])
# 
# 
# q = 1
# somme = 0
# if (q == 1) {
#   for (g in data[data$sample == "~04A_1",]$count) {
#     ps=(g/(sum(data[data$sample == "~04A_1",]$count)))
#     somme = somme + ps*log(ps)
#     print("a")
#   }
#   Hill <- exp(-somme)
# }else{
#   for (g in data[data$sample == "~04A_1",]$count) {
#     ps=(g/(sum(data[data$sample == "~04A_1",]$count)))
#     somme = somme + ps^q
#     print("b")
#   }
#   Hill <- somme^(1/(1-q))
# }
# print(Hill)
```

# version propre du if des valeurs du spèctre de Hill pour l'échantillon ~04A_1
```{r}
q = 
somme = 0
if (q == 1) {

    ps=((data[data$sample == "~04A_1",]$count)/(sum(data[data$sample == "~04A_1",]$count)))
    somme = sum(ps*log(ps))
  Hill <- exp(-somme)
}else{
      ps=((data[data$sample == "~04A_1",]$count)/(sum(data[data$sample == "~04A_1",]$count)))
    somme = sum(ps^q)
    print("b")
  Hill <- somme^(1/(1-q))
}
print(Hill)

```







regrouper les échantillons en provenance d'une même espèce (espèce observée dans data) et observer la biodiv


chercher si sequence connues ont des noms identiques à ceux proposés dans le NCBI blast






