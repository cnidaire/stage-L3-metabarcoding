---
title: "Script_stage"
author: "Rémi Legrand"
date: "03/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Package à nécessaires
```{r warning=FALSE}
library(reshape)
library(ROBITools2) #analyse des données métabarcoding
library(ggplot2) #affichage graphique avancé
library(dplyr) #pour manipuler les données
library(tidyr) #idem
library(stringr) #pour manipuler les chaînes de caractères
library(openxlsx) #pour manipuler les fichiers .xlsx
```

## Imporation des données
```{r}
motus <- read.table("motus_afrique_sud_remi.txt")
data <- read.table("data_afrique_sud_remi.txt")
samples <- read.table("samples_afrique_sud_remi.txt")
reference <- read.xlsx("Plant reference collection sequence information.xlsx",
                       sheet = 2)
```


# Prise en main et visualisation des données

head donne les 6 premières lignes
dim donne les dimensions
memo: peuplier[c(3,7,9),c('Annee','Hauteur')]
peuplier[peuplier$Age == x, ]
peuplier[peuplier$Hauteur > 10,c('Diametre','Age','Hauteur')]



```{r}
# head(motus)
# View(motus)
# head(data)
# dim(data)
# head(samples)
# head(reference)
# dim(reference)

sum(data[data$motu == "GH000001",]$count)  #   attention, ne fonctionne pas et je ne sais pas pourquoi
```
plus practique je pense
```{r}
# summary(motus)
# summary(data)
# summary(samples)
# summary(reference)
```

ce que contiennent les jeux de données:
  - motus: contient l'id, le nombre de lecture et la séquence
  - data: contient le motu(=id), le numéro d'échantillon (plusieurs échantillons différents pour un même motu) et son nombre de lecture
  - samples: contient chacune des séquences, l'espèce attendue, 
  - reference: nom de l'espèce et la séquence de référence associée


mini objectifs: 
  - calculer le nombre de lecture par échantillon
  - le nombre de variant par échantillon
  - le nombre d'animaux différents

### Nombre de lecture par échantillon

c'est une donnée que l'on a déjà dans le fichier data, su nous voulons par motu, on l'a déjà dans le fichier motu mais il est possible de le faire manuellement comme sylvain l'a montré en faisant quelque chose ressemblant à  sum(data[data$motu == "GH000001"]). 

mais cela ne fonctionne pas chez moi car je ne sais plus comment dire la colonne qu'il faut sommer

il suffirait de le faire en boucle for allant de 1 à length(motu) (ce n'est pas length mais plutôt width mais cette commande n'existe pas) et pour chaque itération remplacer le motu recherché et ainsi faire le somme et ensuite ajouter le résultat dans une liste contenant en première colonne le nom de l'échantillon et en deuxième le nombre de lecture de cet échantilon.

```{r}
# View(motus)
# View(data)
# View(samples)
# View(reference)
# pour avoir nombre colonne et de lignes de motus:
length(motus)
nrow(motus)
```


### Nombre de variants par échantillons

pour cela, il faut compter combien de d'échantillons différents ont le même motu dans le fichier data. on peut le faire avec une boucle for mais je pense qu'il y a moyen de faire plus simplement et proprement.

```{r}
# for (i in c(1,length(motus)) {
#   
# }

```




```{r}
# nrow(samples)
compt=0
for (i in c(1:nrow(samples))) {
  if (!is.na(samples$observed_scientific_name[i])) {
    if (samples$observed_scientific_name[i] == "Loxodonta africana") {
    compt=compt+1
    }
  }
}
table(samples$observed_scientific_name)
print(compt)
# samples$observed_scientific_name
unique(samples$observed_scientific_name) # retire les noms d'espèces en doublons

samples%>%group_by(samples$observed_scientific_name)%>%summarise(echantillon = n()) # n() est une fonction de décompte
```



```{r}

lcs_score("AAAA","AAATAA", similarity_mode = "distance")$score
lcs_score(motus[1,]$sequence, motus$sequence, similarity_mode = "distance")$score

is_dist_1_or_0("AACAAGCC", c("AACAAGCC", "AAAAGCC", "ATCAAGCC", "AACATGCG"))



```

Les 1 011 variants variants de la base de données ont été retenus sur un critère de similarité génétique. Etudie la distance entre chacun des variants. Représentation avec une heatmap. Comment interpréter ces proximités (ou non) entre les variants ?

```{r}
# for (a in c(1:nrow(motus))) {
#   for (b in c(1:nrow(motus))) {
#     matrice[a,b] <- lcs_score(motus$sequence[a],motus$sequence[b], similarity_mode = "distance")$score
#   }
# }

matrice <- matrix(data = 0, nrow = nrow(motus), ncol = nrow(motus))
# matrice

for (a in 1:nrow(motus)) {
  matrice[a,] <-lcs_score(motus[a,]$sequence, motus$sequence, similarity_mode = "distance")$score
}

# View(matrice)
lineaire <- melt(matrice)# permet de transformer la matrice en une matrice plus longue avec sa localisation en x et y ainsi que sa valeur
colnames(lineaire) <- c("x", "y", "value")
# print(lineaire)

ggplot(lineaire, aes(x = x, y = y, fill = value))+
  geom_tile() +
  coord_fixed()
```


```{r}
matrice50 <- log(matrice[1:50,1:50])
# matrice

lineaire <- melt(matrice50)# permet de transformer la matrice en une matrice plus longue avec sa localisation en x et y ainsi que sa valeur
colnames(lineaire) <- c("x", "y", "value")
# print(lineaire)

ggplot(lineaire, aes(x = x, y = y, fill = value))+
  geom_tile() +
  coord_fixed()

# ggplot(lineaire, aes(x = x, y = y, fill = log(value)))+
#   geom_tile() +
#   coord_fixed()

# motus$sequence[1]
```

Une première difficulté est que certaines espèces (réelles) ont des séquences très proches les unes des autres. A partir de la base de référence fournie (Plant référence collection séquence information.xlsx ), peut-on distinguer des espèces réelles de probables erreurs PCR ? Annote la base de données "motus" avec l’espèce correspondante, quand elle est identifiée.

```{r}
# motus
# motus[ , "plant"] <- 0
# View(motus)

# for (c in 1:nrow(motus)) {
#   motus$plant[c] <-lcs_score(motus[c,]$sequence, reference$Taxonomic.rank, similarity_mode = "distance")$score
# }
## problème car ce que j'essaie d'implanter dans dans la colonne plant de motus n'a pas la même dimension que plant
nombre_t <- 0
motus[ , "dans_ref"] <- F
for (c in 1:nrow(motus)) {
  if (motus$sequence[c] %in% reference$Sequence.ID) {
    motus$dans_ref[c] <- T
    nombre_t <- nombre_t+1
  }
}
# 
# for (d in 1:nrow(reference)) {
#     if(lcs_score(motus$sequence[1], reference$Sequence.ID[d], similarity_mode = "distance")$score == 0){
#       motus$espece[1] = reference$Scientific.name[d]
#     }
# }
nombre_identifie <- 0
motus[ , "espece"] <- NA
# for (c in 1:nrow(motus)) {
#   if (motus$dans_ref[c]) {
#     for (d in 1:nrow(reference)) {
#       if (lcs_score(motus$sequence[c], reference$Sequence.ID[d], similarity_mode = "distance")$score == 0) {
#         motus$espece[c] <- reference$Scientific.name[d]
#         nombre_identifie = nombre_identifie+1
#       }
#     }
#   }
# }
## fonctionne mais lent
nombre_identifie <- 0
for (c in 1:nrow(motus)) {
  if (motus$dans_ref[c]) {
    motus$espece[c] <- reference$Scientific.name[reference$Sequence.ID == motus$sequence[c]]
    nombre_identifie = nombre_identifie+1
  }
}
# attention, la façon d'écrire et beaucoup plus belle et efficace dans R que d'utiliser une boucle for comme laissé précédemment, à retenir.

View(motus)
# !is.na(motus$espece)
```
il faut donc vérifier si deux séquences sont similaires et si elles sont égales alors remplacer le 0 par le nom de l'espèce que l'on a trouvé.
on ne put pas utiliser une deuxième boucle for, cela serait trop lent, il va donc falloir parcourir la base de données en utilisant robitools mais je ne suis pas sûr qu'en faisant cela, on puisse récupérer le nom de la séquence de réf correspondant.
if lcs = 0 alors remplacer par le nom de l'espèce utilisée. avec deux boucle for, facile mais lent.
si on utilise comparaison de séquence avec groupe de seq, on se retrouve avec une liste de distance mais je ne sais pas comment faire autrement qu'avec une boucle for pour récupérer l'info de si il y a une valeur de 0 présente.

<!-- ajouter une colonne plante selon si la séquence est présente dans la base de données de référence -->

# Indicateur de biodiversité

## Deffinition du nombre de HILL (diversité)

point 1.1.3 du Rapport de Sylvain Moinard

L’entropie est la surprise moyenne apportée par l’observation des individus d’une communauté, d’autant plus grande qu’un individu appartient à une espèce plus rare. 
L’entropie HCDT permet d’unifier les indices classiques de diversité : son paramètre, appelé ordre, fixe l’importance donnée aux espèces rares. L’entropie d’ordre 0 est la richesse ; celle d’ordre 1,l’indice de Shannon ; celle d’ordre 2, celui de Simpson.
L’entropie va de pair avec la diversité au sens strict (Nombres de Hill) : le nombre d’espèces équiprobables dont l’entropie est la même que celle de la communauté réelle. 
Les profils de diversité représentent la diversité en fonction de son ordre et permettent la comparaison de communautés.

L’estimation de la diversité est difficile pour des ordres inférieurs à 0, 5 dans des taxocènes très divers comme les arbres des forêts tropicales.
( page 54 du lire de Eric Marcon 2015)

On décide d’analyser une famille d’indices : les nombres de Hill, qui correspondent à un nombre équivalent d’espèces présentes dans l’écosystème étudié.

```{r}
# q=1
# sum(motus$count)
# sum(motus$count[motus$dans_ref==T])

# motus$count[e][motus$dans_ref == T]
## j'aimerais bien écrire cela mais je n'arrive pas à extraire ce que je veux, il faut donc que je passe par un if


# somme <- 0
# for (e in 1:nrow(motus)) {
#   if (motus$dans_ref[e] == TRUE){
#     somme <- somme + (motus$count[e]/sum(motus$count[motus$dans_ref==T]))^q
#   }
# }
# Hill <- somme^(1/(1-q))
# print(Hill)
# dans le cas où on ne veut étudier la diversité seulement sur les espèces répertoriées.




q=0
somme <- 0
if (q==1) {
  for (e in 1:nrow(motus)) {
    somme <- somme + (motus$count[e]/sum(motus$count))*log(motus$count[e]/sum(motus$count))
  }
  Hill <- exp(-somme)
  print("a")
}else{
  for (e in 1:nrow(motus)) {
    somme <- somme + (motus$count[e]/sum(motus$count))^q
  }
  Hill <- somme^(1/(1-q))
  print("b")
}
print(Hill)
# dans le cas où on veut étudier la diversité sur toutes les séquences
```
quand on exécute pour q=0, on obtient bien 18, ce qui correspond au nombre d'espèces étudiées
il reste le problème pour Q=0, il calcule -inf. il faut donc utiliser un dvp limité


plotter la biodiversité en fonction de q
```{r}
# réalisation d'une fonction que l'on pourra utiliser pour notre graphique
Biodiv <- function(q) {
  somme <- 0
  if (q==1) {
    for (e in 1:nrow(motus)) {
      somme <- somme + (motus$count[e]/sum(motus$count))*log(motus$count[e]/sum(motus$count))
    }
    Hill <- log(exp(-somme))
    # print("a")
  }else{
    for (e in 1:nrow(motus)) {
      somme <- somme + (motus$count[e]/sum(motus$count))^q
    }
    Hill <- log(somme^(1/(1-q)))
    # print("b")
  }
}
x <- seq(0,3,0.1)
plot(x,sapply(x, Biodiv, simplify = TRUE, USE.NAMES = TRUE),main = "Évolution de l'indice de biodiversité en fonction de q", type = "l",xlab = "valeur de q", ylab = "log (indice de biodiversité)")
# utilisation de sapply, nous permettant d'exécuter plusieurs fois la fonction avec des valeurs différentes 
#passer echelle log
# entre 0-3

# Apprendre à faire le graphique sous GGplot pour qu'il soit plus propre
```
que se passe il quand q tend vers infini

```{r}

```

## Étude des Ps, de leurs répartition et de leurs répartition selon leurs présence ou non dans la base de données.

tracer l'histogramme des log(ps) ainsi que ceux des log(ps) présents dans la référence et un autre avec ceux qui n'y sont pas

```{r}
ps <- c()

for (f in 1:nrow(motus)) {
  ps <- c(ps,motus$count[f]/sum(motus$count))
  
}
qplot(ps, main = "Histogramme de répartition ps ADN séquencé")+scale_y_log10()+scale_x_log10()
# dans le cas où on observe tout les ps
```
On peut  observer que très peu d'espèces ont un ps supérieur à 10^-2, et sont donc extremement représenté dans le nombre de lectures alors que la plus part des espèces ontmoins de 10^-2.

```{r}
ps <- c()
for (g in 1:nrow(motus)) {
  if (motus$dans_ref[g] == TRUE){
    ps <- c(ps,motus$count[g]/sum(motus$count[motus$dans_ref==T]))
  }
}
qplot(ps, main = "Histogramme de répartition ps espèces présentes dans fichier réference")
# dans le cas où on observe juste ceux présents dans la base de données de référence
```
Ici, on peut voir que la quasi totalité  des 

```{r}
ps <- c()
for (h in 1:nrow(motus)) {
  if (motus$dans_ref[h] == F){
    ps <- c(ps,motus$count[h]/sum(motus$count[motus$dans_ref==F]))
  }
}
qplot(ps, main = "Histogramme de répartition ps séquences absentes fichier réference")+scale_y_log10()+scale_x_log10()
# dans le cas où on observe juste ceux non présents dans la base de données de référence
```
*je pense qu'il sera dur de tirer des conclusions en comparant les différents graph étant donné que pour obtenir ps, on divise pas la somme des counts, qui n'est pas la même, ce sont donc deux infos mais difficilement comparables*



### re-agréger les données de data_count  afin de vérifier si on obtient bien motus_count

```{r}
data_count <- s # n() est une fonction de décompte
# donc il y a un problème car j'obtient le nombre de fois que le motu apparais dans data


nrow(data_count)
data_count

data_count$count == motus$count

```











motus agrégé (ça je ne me souviens plus de ce que je devais faire).

échantillon par échantillon à partir de data

regrouper les échantillons en provenance d'une même espèce (espèce observée dans data) et observer la biodiv







