---
title: "Graphe_et_traitement_de_donnees"
author: "Rémi Legrand"
date: "12/01/2022"
output: 
  html_document :
    toc: true # table of content true
    toc_float: True
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
---

# Importation des packages necessaires et des données

```{r message=FALSE, warning=FALSE}
library(reshape)
library(ROBITools2) #analyse des données métabarcoding
library(ggplot2) #affichage graphique avancé
library(dplyr) #pour manipuler les données
library(tidyr) #idem
library(stringr) #pour manipuler les chaînes de caractères
library(openxlsx) #pour manipuler les fichiers .xlsx
library(igraph)
```

```{r}
motus2 <- read.table("motus_afrique_sud_remi2.txt")
data2 <- read.table("data_afrique_sud_remi2.txt")
samples2 <- read.table("samples_afrique_sud_remi2.txt")
reference <- read.xlsx("Plant reference collection sequence information.xlsx", 
                       sheet = 2)
motus <- read.table("motus_afrique_sud_remi.txt")
data <- read.table("data_afrique_sud_remi.txt")
samples <- read.table("samples_afrique_sud_remi.txt")
```




# Rédaction de fonction pour le traitement des distances entre les motus et le tracé du graphe


## Fonction pour calculer la matrice de distance
```{r}
matrice_distance <- function(base_donnee, seuil) {
  base_donnee_bis <- base_donnee[base_donnee$count > seuil,] # création d'une nouvelle base de donné qui ne contient que des motus dont le nombre de reads est supérieur au seuil.
  
  x <- sapply(base_donnee_bis$sequence[1:nrow(base_donnee_bis)], lcs_score, base_donnee_bis$sequence[1:nrow(base_donnee_bis)], similarity_mode = "distance")
  
  matrice_dist <- matrix(unlist(x), nrow = length(base_donnee_bis$sequence[1:nrow(base_donnee_bis)]), ncol = length(base_donnee_bis$sequence[1:nrow(base_donnee_bis)]), byrow = T)
  
  return(matrice_dist)
}

distance <- matrice_distance(motus2, 2000)
ncol(distance)
nrow(distance)
# View(distance)
```

On obtient une matrice contenant les distance génétiques entre les différents motus avec un nombre de lecture supérieur à une valeur seuil.

## Fonction pour savoir si l'espèce est dans la ref

```{r}
dans_ref <- function(base_donnee, ref){
  base_donnee[,"dans_ref"] <- F
  nrow(base_donnee)
  for (c in 1:nrow(base_donnee)) {
    if (base_donnee$sequence[c] %in% ref$Sequence.ID) {
      base_donnee$dans_ref[c] <- T
      
    }
  }
  return(base_donnee)
}

motus2_ref <- dans_ref(motus2, reference)
```

Ici, on annote la base de données en ajoutant une nouvelle colonne et si la séquence appartient à la base de données, alors, il y a marqué True dans la base de données.

## Fonction pour la matrice de distance

```{r}
matrice_adjacence <- function(matrice_distance, base_donnee_ref){
  couleur <- NULL
  matrice_adj <- matrix(data = NA, nrow = nrow(matrice_distance), ncol = ncol(matrice_distance))
  for (i in 1:nrow(matrice_distance)) {
    if (base_donnee_ref$dans_ref[i] == T) {
      matrice_adj[i,] <- 0 # n'est lié à rien d'autre
      couleur <- rbind(couleur, "green")
    }else {
      if (1 %in% matrice_distance[i,1:(i-1)]) { # si il y a au moins un motu à 1 de distance génétique
        a <- which(matrice_distance[i,1:(i-1)] == 1) # on marque lesquels sont à un de distance
        if (length(a) == 1) {
          matrice_adj[i,] <- 0
          matrice_adj[i,a] <- 1 # se rattache à cette espèce
          couleur <- rbind(couleur, "yellow")
        }else {
          matrice_adj[i,] <- 0
          matrice_adj[i,a] <- 1 # lié aux deux mais perte de l'info de la répartition entre les deux
          couleur <- rbind(couleur, "yellow")
        }
      }else{
        matrice_adj[i,] <- 0 # définition d'une probable nouvelle espèce
        couleur <- rbind(couleur, "red")
      }
    }
  }
  return(matrice_adj)
}

matrice_adj <- matrice_adjacence(distance, motus2_ref)
# nrow(matrice_adj)
# ncol(matrice_adj)
# View(matrice_adj)
```

## fonction pour obtenir une liste avec les couleurs

```{r}
liste_couleur <- function(matrice_distance, base_donnee_ref){
  couleur <- NULL
  matrice_adj <- matrix(data = NA, nrow = nrow(matrice_distance), ncol = ncol(matrice_distance))
  for (i in 1:nrow(matrice_distance)) {
    if (base_donnee_ref$dans_ref[i] == T) {
      couleur <- rbind(couleur, "green")
    }else {
      if (1 %in% matrice_distance[i,1:(i-1)]) { # si il y a au moins un motu à 1 de distance génétique
          couleur <- rbind(couleur, "yellow")
      }else{
        couleur <- rbind(couleur, "red")
      }
    }
  }
  return(couleur)
}

couleur <- liste_couleur(distance, motus2_ref)
length(couleur)
couleur[2:5]
```
## fonction filtrant les motus isolés génétiquement des autres 

```{r}
filtre_isolement <- function(matrice_adjacence) {
  motus_a_supr <- NULL
  for (i in 1:nrow(matrice_adjacence)) {
    if (is.null(which(1 %in% matrice_adjacence[i,])) & is.null(which(1 %in% matrice_adjacence[i,]))) {
      motus_a_supr <- c(motus_a_supr,i)
    }
  }
  return(motus_a_supr)
}

motus_a_supr <- filtre_isolement(matrice_adj)
motus_a_supr

matrice_adj[motus_a_supr,] <- NULL
matrice_adj[,motus_a_supr] <- NULL
couleur[motus_a_supr] <-NULL
```

pour l'instant, ne semble rien filtrer du tout puique motus_a_supr est vide


## fonction pour tracer le graphe

```{r}
graphe <- function(matrice_adjacence,base_donnee, couleur) {
  graph_liens <- graph_from_adjacency_matrix(matrice_adjacence[1:nrow(matrice_adjacence),1:nrow(matrice_adjacence)])
  V(graph_liens)$color <- couleur
  V(graph_liens)$size <- 3*log10(base_donnee$count)

  return(tkplot(graph_liens, mode='directed'))
}
graphe(matrice_adj, motus2, couleur)
```


# Création d'un pdf contenant le spectre de Hill propre à chacun des animaux

```{r}
View(samples2)
View(data2)
View(motus2)
```

```{r}
length(unique(samples2$observed_scientific_name))
```

```{r}
# data2["espece"] <-NA
# 
# for (i in 1:nrow(data2)) {
#   if (!is.null(which(samples2$id == data2$sample[i]))) { # remplir un vecteur des échantillons de data avec un nom correspondant à celui de l'échantillon, si ce vecteur n'est pas vide, alors continuer
#     data2$espece[i] <- samples2$observed_scientific_name[samples2$id == data2$sample[i]] #ici, on prend le nom correspondant et on le met dans la colonne espece associée
#   }
# }
```

sur cette base de donnée entière, cela demande 20 min de calcul

```{r}
View(data)
View(samples)
data["espece"] <-NA

for (i in 1:nrow(data)) {
  if (!is.null(which(samples$id == data$sample[i]))) { # remplir un vecteur des échantillons de data avec un nom correspondant à celui de l'échantillon, si ce vecteur n'est pas vide, alors continuer
    data$espece[i] <- samples$observed_scientific_name[samples$id == data$sample[i]] #ici, on prend le nom correspondant et on le met dans la colonne espece associée
  }
}

unique(data$espece)
```
sur celle ci, demande environ 6 min de calcul



```{r}
spectre_hill <- function(q,nom_espece){
  ps <- ((data[data$espece == nom_espece,]$count)/(sum(data[data$espece == nom_espece,]$count))) # ratio du nombre de count par motu sur le nombre de count des motu
  if (q == 1) {
    a <- exp(-sum(ps*log(ps)))
  }else {
    a <- sum(ps^q)^(1/(1-q))
  }
  return(a)
}
nombre_q <- seq(0,1,1)
# ici, nous avons dû utiliser la fonction couplée avec un if et un esle au lieu d'un if else, ce qui fait qu'il ne peut rentrer dans la fonction qu'une seule valeur, pour pouvoir rentre un vecteur, il va falloir recourir à sapply.
sapply(nombre_q,spectre_hill,"Phacochoerus africanus") # exemple pour une espèce random.
spectre_hill(0, "Phacochoerus africanus")
length(which(data$espece == "Phacochoerus africanus"))
```
























