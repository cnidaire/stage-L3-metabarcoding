---
title: "Graphe_et_traitement_de_donnees"
author: "Rémi Legrand"
date: "12/01/2022"
output: 
  html_document :
    toc: true # table of content true
    toc_float: True
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
---

# Importation des packages necessaires et des données

```{r message=FALSE, warning=FALSE}
library(reshape)
library(ROBITools2) #analyse des données métabarcoding
library(ggplot2) #affichage graphique avancé
library(dplyr) #pour manipuler les données
library(tidyr) #idem
library(stringr) #pour manipuler les chaînes de caractères
library(openxlsx) #pour manipuler les fichiers .xlsx
library(igraph)
```

```{r}
motus2 <- read.table("motus_afrique_sud_remi2.txt")
data2 <- read.table("data_afrique_sud_remi2.txt")
samples2 <- read.table("samples_afrique_sud_remi2.txt")
reference <- read.xlsx("Plant reference collection sequence information.xlsx", 
                       sheet = 2)
motus <- read.table("motus_afrique_sud_remi.txt")
data <- read.table("data_afrique_sud_remi.txt")
samples <- read.table("samples_afrique_sud_remi.txt")
```

# Rédaction de fonction pour le traitement des distances entre les motus et le tracé du graphe


## Fonction pour calculer la matrice de distance
```{r}
matrice_distance <- function(base_donnee, seuil) {
  base_donnee_bis <- base_donnee[base_donnee$count > seuil,] # création d'une nouvelle base de donné qui ne contient que des motus dont le nombre de reads est supérieur au seuil.
  
  x <- sapply(base_donnee_bis$sequence[1:nrow(base_donnee_bis)], lcs_score, base_donnee_bis$sequence[1:nrow(base_donnee_bis)], similarity_mode = "distance")
  
  matrice_dist <- matrix(unlist(x), nrow = length(base_donnee_bis$sequence[1:nrow(base_donnee_bis)]), ncol = length(base_donnee_bis$sequence[1:nrow(base_donnee_bis)]), byrow = T)
  
  return(matrice_dist)
}

distance <- matrice_distance(motus2, 2000)
ncol(distance)
nrow(distance)
# View(distance)
```

On obtient une matrice contenant les distance génétiques entre les différents motus avec un nombre de lecture supérieur à une valeur seuil.

## Fonction pour savoir si l'espèce est dans la ref

```{r}
dans_ref <- function(base_donnee, ref){
  base_donnee[,"dans_ref"] <- F
  nrow(base_donnee)
  for (c in 1:nrow(base_donnee)) {
    if (base_donnee$sequence[c] %in% ref$Sequence.ID) {
      base_donnee$dans_ref[c] <- T
      
    }
  }
  return(base_donnee)
}

motus2_ref <- dans_ref(motus2, reference)
```

Ici, on annote la base de données en ajoutant une nouvelle colonne et si la séquence appartient à la base de données, alors, il y a marqué True dans la base de données.

## Fonction pour la matrice de distance

```{r}
matrice_adjacence <- function(matrice_distance, base_donnee_ref){
  couleur <- NULL
  matrice_adj <- matrix(data = NA, nrow = nrow(matrice_distance), ncol = ncol(matrice_distance))
  for (i in 1:nrow(matrice_distance)) {
    if (base_donnee_ref$dans_ref[i] == T) {
      matrice_adj[i,] <- 0 # n'est lié à rien d'autre
      couleur <- rbind(couleur, "green")
    }else {
      if (1 %in% matrice_distance[i,1:(i-1)]) { # si il y a au moins un motu à 1 de distance génétique
        a <- which(matrice_distance[i,1:(i-1)] == 1) # on marque lesquels sont à un de distance
        if (length(a) == 1) {
          matrice_adj[i,] <- 0
          matrice_adj[i,a] <- 1 # se rattache à cette espèce
          couleur <- rbind(couleur, "yellow")
        }else {
          matrice_adj[i,] <- 0
          matrice_adj[i,a] <- 1 # lié aux deux mais perte de l'info de la répartition entre les deux
          couleur <- rbind(couleur, "yellow")
        }
      }else{
        matrice_adj[i,] <- 0 # définition d'une probable nouvelle espèce
        couleur <- rbind(couleur, "red")
      }
    }
  }
  return(matrice_adj)
}

matrice_adj <- matrice_adjacence(distance, motus2_ref)
# nrow(matrice_adj)
# ncol(matrice_adj)
# View(matrice_adj)
```

## fonction pour obtenir une liste avec les couleurs

```{r}
liste_couleur <- function(matrice_distance, base_donnee_ref){
  couleur <- NULL
  matrice_adj <- matrix(data = NA, nrow = nrow(matrice_distance), ncol = ncol(matrice_distance))
  for (i in 1:nrow(matrice_distance)) {
    if (base_donnee_ref$dans_ref[i] == T) {
      couleur <- rbind(couleur, "green")
    }else {
      if (1 %in% matrice_distance[i,1:(i-1)]) { # si il y a au moins un motu à 1 de distance génétique
          couleur <- rbind(couleur, "yellow")
      }else{
        couleur <- rbind(couleur, "red")
      }
    }
  }
  return(couleur)
}

couleur <- liste_couleur(distance, motus2_ref)
length(couleur)
couleur[2:5]
```
## fonction filtrant les motus isolés génétiquement des autres 

```{r}
filtre_isolement <- function(matrice_adjacence) {
  motus_a_supr <- NULL
  for (i in 1:nrow(matrice_adjacence)) {
    if (is.null(which(1 %in% matrice_adjacence[i,])) & is.null(which(1 %in% matrice_adjacence[i,]))) {
      motus_a_supr <- c(motus_a_supr,i)
    }
  }
  return(motus_a_supr)
}

motus_a_supr <- filtre_isolement(matrice_adj)
motus_a_supr

matrice_adj[motus_a_supr,] <- NULL
matrice_adj[,motus_a_supr] <- NULL
couleur[motus_a_supr] <-NULL
```

pour l'instant, ne semble rien filtrer du tout puique motus_a_supr est vide


## fonction pour tracer le graphe

```{r}
graphe <- function(matrice_adjacence,base_donnee, couleur) {
  graph_liens <- graph_from_adjacency_matrix(matrice_adjacence[1:nrow(matrice_adjacence),1:nrow(matrice_adjacence)])
  V(graph_liens)$color <- couleur
  V(graph_liens)$size <- 3*log10(base_donnee$count)

  return(tkplot(graph_liens, mode='directed'))
}
graphe(matrice_adj, motus2, couleur)
```


# Création d'un pdf contenant le spectre de Hill propre à chacun des animaux

```{r}
View(samples2)
View(data2)
View(motus2)
```

```{r}
length(unique(samples2$observed_scientific_name))
```

```{r}
# data2["espece"] <-NA
# 
# for (i in 1:nrow(data2)) {
#   if (!is.null(which(samples2$id == data2$sample[i]))) { # remplir un vecteur des échantillons de data avec un nom correspondant à celui de l'échantillon, si ce vecteur n'est pas vide, alors continuer
#     data2$espece[i] <- samples2$observed_scientific_name[samples2$id == data2$sample[i]] #ici, on prend le nom correspondant et on le met dans la colonne espece associée
#   }
# }
```

sur cette base de donnée entière, cela demande 20 min de calcul

```{r}
View(data)
View(samples)
data["espece"] <-NA

for (i in 1:nrow(data)) {
  if (!is.null(which(samples$id == data$sample[i]))) { # remplir un vecteur des échantillons de data avec un nom correspondant à celui de l'échantillon, si ce vecteur n'est pas vide, alors continuer
    data$espece[i] <- samples$observed_scientific_name[samples$id == data$sample[i]] #ici, on prend le nom correspondant et on le met dans la colonne espece associée
  }
}

unique(data$espece)
```
sur celle ci, demande environ 6 min de calcul

Je tente avec une fonction de plus haut niveau:
```{r}
data %>% left_join(select(samples,id,ob0served_scientific_name) , by = c("sample" = "id")) %>%
  drop_na() %>% rename(espece = observed_scientific_name) -> data
```


```{r}
spectre_hill <- function(q,nom_espece){
  ps <- ((data[!is.na(data$espece) & data$espece == nom_espece,]$count)/(sum(data[!is.na(data$espece) & data$espece == nom_espece,]$count))) # ratio du nombre de count par motu sur le nombre de count des motu en homettant les NA qui par defaut semblent être considérés comme des TRUE
  if (q == 1) {
    a <- exp(-sum(ps*log(ps)))
  }else {
    a <- sum(ps^q)^(1/(1-q))
  }
  return(a)
}
spectre_hill2 <- function(val,q){
  ps <- val/sum(val)
  if (q == 1) {
    a <- exp(-sum(ps*log(ps)))
  }else {
    a <- sum(ps^q)^(1/(1-q))
  }
  return(a)
}

nombre_q <- seq(0,6,1)
Qd <- sapply(nombre_q,spectre_hill,"Tragelaphus oryx") # exemple pour une espèce random. mais ne fonctionne que pour le 0


length(data[!is.na(data$espece) & data$espece == "Tragelaphus oryx",]$count)# petite verif pour q=0 (qui compte le nombre de motus différents )
```

```{r}
nombre_q <- seq(0,3,0.1)
df <- NULL
df <- rbind(df, data.frame(q=nombre_q, Qd <- sapply(nombre_q,spectre_hill,"Tragelaphus oryx")))
ggplot(data = df, aes(x = q, y = log10(Qd))) +
  geom_line() +
  ggtitle("Spectre de Hill pour l'alimentation de Tragelaphus oryx") + 
  theme(plot.title = element_text(hjust = 0.5))
```


```{r}
system.time({
  especes = unique(data$espece)
  especes = especes[!is.na(especes)]
  nombre_q <- seq(0,3,0.1)
  for (e in especes) {
    df <- data.frame(q = nombre_q, Qd = sapply(nombre_q,spectre_hill,e))
    # print(df)
    p = ggplot(data = df, aes(x = q, y = Qd)) +
      geom_line() + scale_y_log10(limits=c(1,1E5)) +
      ggtitle(paste("Spectre de Hill pour l'alimentation de", e)) + 
      theme(plot.title = element_text(hjust = 0.5))
    print(p)
  }
})
```


```{r}
data %>% drop_na() -> data

especes = unique(data$espece)
especes = especes[!is.na(especes)]

q_values = seq(0,3,0.1)

# Version lente avec sapply
df = data.frame()
system.time({
  for (e in especes) {
    df <- rbind(df, data.frame(espece = e, q = q_values, Qd = sapply(q_values,spectre_hill,e)))
    # print(df)
  }
})

# Version rapide et moderne avec le tidyverse !!! :)
df = data.frame()
system.time({
  for (e in especes) {
    d = data.frame(espece = e, q = q_values)
    val = data[data$espece == e,]$count
    df <- rbind(df, d %>% group_by(q) %>% mutate(Qd =  spectre_hill2(val = val, q = q)))
    # print(df)
  }
})

# expand.grid(espece = especes, q = q_values) %>%
#   nest_by(espece) %>%
#     group_by(q) %>% mutate(Qd =  spectre_hill2(val = data[data$espece == espece,]$count, q = q))

#une autre version un peu lent

expand.grid(espece = especes, q = q_values) %>%
    group_by(espece, q) %>% mutate(Qd =  spectre_hill2(val = data[data$espece == espece,]$count, q = q))

system.time({
  for (e in especes) {
    p = ggplot(data = df[df$espece == e,], aes(x = q, y = Qd)) +
      geom_line() + scale_y_log10(limits=c(1,1E5)) +
      ggtitle(paste("Spectre de Hill pour l'alimentation de", e)) + 
      theme(plot.title = element_text(hjust = 0.5))
    print(p)
  }
})
```

















